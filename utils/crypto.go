/*
* Large-Scale Discovery, a network scanning solution for information gathering in large IT/OT network environments.
*
* Copyright (c) Siemens AG, 2016-2023.
*
* This work is licensed under the terms of the MIT license. For a copy, see the LICENSE file in the top-level
* directory or visit <https://opensource.org/licenses/MIT>.
*
 */

package utils

import (
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"golang.org/x/crypto/bcrypt"
	"golang.org/x/crypto/pbkdf2"
	"io"
)

// CreatePasswordHash creates a salted password hash from a given password
func CreatePasswordHash(pwd string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost+2)
	if err != nil {
		return "", err
	}
	return string(hash), nil
}

// CheckPasswordHash compares a password hash generated by CreatePasswordHash() with a given plaintext password.
// Returns nil if password matches given hash.
func CheckPasswordHash(hashedPwd string, plainPwd string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPwd), []byte(plainPwd))
}

// HashScramSha256Postgres generates a Scram-Sha-256 hash in the format used by Postgres for storing user passwords
func HashScramSha256Postgres(password string) (string, error) {

	// Define amount of iterations to secure the hash
	cost := 4096

	// Prepare some helper functions
	getHMACSum := func(key, msg []byte) []byte { // Calculate HMAC hash
		h := hmac.New(sha256.New, key)
		_, _ = h.Write(msg)
		return h.Sum(nil)
	}
	b64 := func(in []byte) string { // Base64 encode bytes
		out := make([]byte, base64.StdEncoding.EncodedLen(len(in)))
		base64.StdEncoding.Encode(out, in)
		return string(out)
	}

	// Generate random salt
	salt := make([]byte, 16)
	if _, errSalt := io.ReadFull(rand.Reader, salt); errSalt != nil {
		return "", fmt.Errorf("could not generate salt: %s", errSalt)
	}

	// Generate keys and checksums
	keyDigest := pbkdf2.Key([]byte(password), salt, cost, 32, sha256.New)

	// Generate HMACs
	keyServer := getHMACSum(keyDigest, []byte("Server Key"))
	keyClient := getHMACSum(keyDigest, []byte("Client Key"))

	// Generate Sha256 checksum
	hashSha256 := sha256.New()
	_, _ = hashSha256.Write(keyClient)
	keyClientSha256 := hashSha256.Sum(nil)

	// Build SCRAM-SHA-256 hash string and return it
	return fmt.Sprintf("SCRAM-SHA-256$%d:%s$%s:%s", cost, b64(salt), b64(keyClientSha256), b64(keyServer)), nil
}
